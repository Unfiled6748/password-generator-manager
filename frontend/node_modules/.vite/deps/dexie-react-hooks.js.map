{
  "version": 3,
  "sources": ["../../dexie-react-hooks/src/useObservable.ts", "../../dexie-react-hooks/src/useLiveQuery.ts", "../../dexie-react-hooks/src/usePermissions.ts"],
  "sourcesContent": ["import React from 'react';\nexport interface InteropableObservable<T> {\n  subscribe(\n    onNext: (x: T) => any,\n    onError?: (error: any) => any\n  ): (() => any) | { unsubscribe(): any };\n  getValue?(): T; // For BehaviorSubject\n  hasValue?(): boolean; // For liveQuery observable returning false until a value is available\n}\n\nexport function useObservable<T, TDefault>(\n  observable: InteropableObservable<T>\n): T | undefined;\nexport function useObservable<T, TDefault>(\n  observable: InteropableObservable<T>,\n  defaultResult: TDefault\n): T | TDefault;\nexport function useObservable<T>(\n  observableFactory: () => InteropableObservable<T>,\n  deps?: any[]\n): T | undefined;\nexport function useObservable<T, TDefault>(\n  observableFactory: () => InteropableObservable<T>,\n  deps: any[],\n  defaultResult: TDefault\n): T | TDefault;\nexport function useObservable<T, TDefault>(\n  observableFactory:\n    | InteropableObservable<T>\n    | (() => InteropableObservable<T>),\n  arg2?: any,\n  arg3?: any\n) {\n  // Resolve vars from overloading variants of this function:\n  let deps: any[];\n  let defaultResult: TDefault;\n  if (typeof observableFactory === 'function') {\n    deps = arg2 || [];\n    defaultResult = arg3;\n  } else {\n    deps = [];\n    defaultResult = arg2;\n  }\n\n  // Create a ref that keeps the state we need\n  const monitor = React.useRef({\n    hasResult: false,\n    result: defaultResult as T | TDefault,\n    error: null as any,\n  });\n  // We control when component should rerender. Make triggerUpdate\n  // as examplified on React's docs at:\n  // https://reactjs.org/docs/hooks-faq.html#is-there-something-like-forceupdate\n  const [_, triggerUpdate] = React.useReducer((x) => x + 1, 0);\n\n  // Memoize the observable based on deps\n  const observable = React.useMemo(() => {\n    // Make it remember previous subscription's default value when\n    // resubscribing.\n    const observable =\n      typeof observableFactory === 'function'\n        ? observableFactory()\n        : observableFactory;\n    if (!observable || typeof observable.subscribe !== 'function') {\n      if (observableFactory === observable) {\n        throw new TypeError(\n          `Given argument to useObservable() was neither a valid observable nor a function.`\n        );\n      } else {\n        throw new TypeError(\n          `Observable factory given to useObservable() did not return a valid observable.`\n        );\n      }\n    }\n\n    if (!monitor.current.hasResult &&\n        typeof window !== 'undefined' // Don't do this in SSR\n       ) {\n      // Optimize for BehaviorSubject and other observables implementing getValue():\n      if (typeof observable.hasValue !== 'function' || observable.hasValue()) {\n        if (typeof observable.getValue === 'function') {\n          monitor.current.result = observable.getValue();\n          monitor.current.hasResult = true;\n        } else {\n          // Find out if the observable has a current value: try get it by subscribing and\n          // unsubscribing synchronously\n          const subscription = observable.subscribe((val) => {\n            monitor.current.result = val;\n            monitor.current.hasResult = true;\n          });\n          // Unsubscribe directly. We only needed any synchronous value if it was possible.\n          if (typeof subscription === 'function') {\n            subscription();\n          } else {\n            subscription.unsubscribe();\n          }\n        }\n      }\n    }\n    return observable;\n  }, deps);\n\n  // Integrate with react devtools:\n  React.useDebugValue(monitor.current.result);\n\n  // Subscribe to the observable\n  React.useEffect(() => {\n    const subscription = observable.subscribe(\n      (val) => {\n        const { current } = monitor;\n        if (current.error !== null || current.result !== val) {\n          current.error = null;\n          current.result = val;\n          current.hasResult = true;\n          triggerUpdate();\n        }\n      },\n      (err) => {\n        const { current } = monitor;\n        if (current.error !== err) {\n          current.error = err;\n          triggerUpdate();\n        }\n      }\n    );\n    return typeof subscription === 'function'\n      ? subscription // Support observables that return unsubscribe directly\n      : subscription.unsubscribe.bind(subscription);\n  }, deps);\n\n  // Throw if observable has emitted error so that\n  // an ErrorBoundrary can catch it\n  if (monitor.current.error) throw monitor.current.error;\n\n  // Return the current result\n  return monitor.current.result;\n}\n", "import { liveQuery } from 'dexie';\nimport { useObservable } from './useObservable';\n\nexport function useLiveQuery<T>(\n  querier: () => Promise<T> | T,\n  deps?: any[]\n): T | undefined;\nexport function useLiveQuery<T, TDefault>(\n  querier: () => Promise<T> | T,\n  deps: any[],\n  defaultResult: TDefault\n): T | TDefault;\nexport function useLiveQuery<T, TDefault>(\n  querier: () => Promise<T> | T,\n  deps?: any[],\n  defaultResult?: TDefault\n): T | TDefault {\n  return useObservable(\n    () => liveQuery(querier),\n    deps || [],\n    defaultResult as TDefault\n  );\n}\n", "import { Dexie } from 'dexie';\nimport { useObservable } from './useObservable';\n//import type { KeyPaths, TableProp } from 'dexie'; // Issue #1725 - not compatible with dexie@3.\n// Workaround: provide these types inline for now. When dexie 4 stable is out, we can use the types from dexie@4.\nexport type KeyPaths<T> = {\n  [P in keyof T]: \n    P extends string \n      ? T[P] extends Array<infer K>\n        ? K extends object // only drill into the array element if it's an object\n          ? P | `${P}.${number}` | `${P}.${number}.${KeyPaths<K>}` \n          : P | `${P}.${number}`\n        : T[P] extends (...args: any[]) => any // Method\n           ? never \n          : T[P] extends object \n            ? P | `${P}.${KeyPaths<T[P]>}` \n            : P \n      : never;\n}[keyof T];\nexport type TableProp<DX extends Dexie> = {\n  [K in keyof DX]: DX[K] extends {schema: any, get: any, put: any, add: any, where: any} ? K : never;\n}[keyof DX] & string;\n\n\ninterface DexieCloudEntity {\n  table(): string;\n  realmId: string;\n  owner: string;\n}\n\nexport interface PermissionChecker<T, TableName extends string> {\n  add(...tableNames: TableName[]): boolean;\n  update(...props: KeyPaths<T>[]): boolean;\n  delete(): boolean;\n}\n\nexport function usePermissions<T extends DexieCloudEntity>(\n  entity: T\n): PermissionChecker<\n  T,\n  T extends { table: () => infer TableName } ? TableName : string\n>;\nexport function usePermissions<\n  TDB extends Dexie,\n  T extends { realmId: string; owner: string }\n>(db: TDB, table: TableProp<TDB>, obj: T): PermissionChecker<T, TableProp<TDB>>;\nexport function usePermissions(\n  firstArg:\n    | Dexie\n    | {\n        realmId?: string;\n        owner?: string;\n        table?: () => string;\n        readonly db?: Dexie;\n      },\n  table?: string,\n  obj?: { realmId?: string; owner?: string }\n) {\n  if (!firstArg)\n    throw new TypeError(\n      `Invalid arguments to usePermissions(): undefined or null`\n    );\n  let db: Dexie;\n  if (arguments.length >= 3) {\n    if (!('transaction' in firstArg)) {\n      // Using ducktyping instead of instanceof in case there are multiple Dexie modules in app.\n      // First arg is  ensures first arg is a Dexie instance\n      throw new TypeError(\n        `Invalid arguments to usePermission(db, table, obj): 1st arg must be a Dexie instance`\n      );\n    }\n    if (typeof table !== 'string')\n      throw new TypeError(\n        `Invalid arguments to usePermission(db, table, obj): 2nd arg must be string`\n      );\n    if (!obj || typeof obj !== 'object')\n      throw new TypeError(\n        `Invalid arguments to usePermission(db, table, obj): 3rd arg must be an object`\n      );\n    db = firstArg;\n  } else {\n    if (firstArg instanceof Dexie)\n      throw new TypeError(\n        `Invalid arguments to usePermission(db, table, obj): Missing table and obj arguments.`\n      );\n\n    if (\n      typeof firstArg.table === 'function' &&\n      typeof firstArg.db === 'object'\n    ) {\n      db = firstArg.db!;\n      obj = firstArg;\n      table = firstArg.table();\n    } else {\n      throw new TypeError(\n        `Invalid arguments to usePermissions(). ` +\n          `Expected usePermissions(entity: DexieCloudEntity) or ` +\n          `usePermissions(db: Dexie, table: string, obj: DexieCloudObject)`\n      );\n    }\n  }\n  if (!('cloud' in db))\n    throw new Error(\n      `usePermissions() is only for Dexie Cloud but there's no dexie-cloud-addon active in given db.`\n    );\n  if (!('permissions' in (db as any).cloud))\n    throw new Error(`usePermissions() requires a newer version of dexie-cloud-addon. Please upgrade it.`)\n  return useObservable(\n    // @ts-ignore\n    () => db.cloud.permissions(obj, table),\n    [obj.realmId, obj.owner, table]\n  );\n}\n"],
  "mappings": "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",
  "names": ["React", "observable", "liveQuery", "Dexie"]
}
